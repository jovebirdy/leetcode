{"java":"/*\r\n * [729] My Calendar I\r\n *\r\n * https://leetcode.com/problems/my-calendar-i/description/\r\n *\r\n * algorithms\r\n * Medium (42.15%)\r\n * Total Accepted:    10K\r\n * Total Submissions: 23.6K\r\n * Testcase Example:  '[\"MyCalendar\",\"book\",\"book\",\"book\"]\\n[[],[10,20],[15,25],[20,30]]'\r\n *\r\n *\r\n * Implement a MyCalendar class to store your events. A new event can be added\r\n * if adding the event will not cause a double booking.\r\n *\r\n * Your class will have the method, book(int start, int end).  Formally, this\r\n * represents a booking on the half open interval [start, end), the range of\r\n * real numbers x such that start .\r\n *\r\n * A double booking happens when two events have some non-empty intersection\r\n * (ie., there is some time that is common to both events.)\r\n *\r\n * For each call to the method MyCalendar.book, return true if the event can be\r\n * added to the calendar successfully without causing a double booking.\r\n * Otherwise, return false and do not add the event to the calendar.\r\n *\r\n *\r\n * Your class will be called like this:\r\n * MyCalendar cal = new MyCalendar();\r\n * MyCalendar.book(start, end)\r\n *\r\n * Example 1:\r\n *\r\n * MyCalendar();\r\n * MyCalendar.book(10, 20); // returns true\r\n * MyCalendar.book(15, 25); // returns false\r\n * MyCalendar.book(20, 30); // returns true\r\n * Explanation:\r\n * The first event can be booked.  The second can't because time 15 is already\r\n * booked by another event.\r\n * The third event can be booked, as the first event takes every time less than\r\n * 20, but not including 20.\r\n *\r\n *\r\n *\r\n * Note:\r\n * The number of calls to MyCalendar.book per test case will be at most 1000.\r\n * In calls to MyCalendar.book(start, end), start and end are integers in the\r\n * range [0, 10^9].\r\n *\r\n */\r\nclass MyCalendar {\r\n\r\n    TreeMap<Integer, Integer> map;\r\n    public MyCalendar() {\r\n      map = new TreeMap<>();\r\n    }\r\n\r\n    public boolean book(int start, int end) {\r\n        Integer floor = map.floorKey(end - 1);\r\n        if (floor != null && (floor >= start || map.get(floor) > start))\r\n            return false;\r\n        map.put(start, end);\r\n        return true;\r\n    }\r\n}\r\n\r\n/* faster solution, using binary tree\r\nclass MyCalendar2 {\r\n\r\n    class Node {//节点有起始结束时间和左右子节点\r\n        public Node(int start, int end) {\r\n            l = start;\r\n            r = end;\r\n        }\r\n\r\n        int l, r;\r\n        Node left, right;\r\n    }\r\n\r\n    Node root = null;\r\n\r\n    public boolean book(int start, int end) {\r\n        if (root == null) {\r\n            root = new Node(start, end);\r\n        } else {\r\n            Node cur = root;\r\n            Node pre = null;//父节点\r\n            boolean leftTag = false;//记录该插入的节点是左子还是右子\r\n            while (cur != null) {\r\n                pre = cur;\r\n                if (end <= cur.l) {//应该在当前节点的左侧，往左子递归\r\n                    leftTag = true;\r\n                    cur = cur.left;\r\n                } else if (start >= cur.r) {//应该在当前节点的右侧，往右子递归\r\n                    leftTag = false;\r\n                    cur = cur.right;\r\n                } else {// 有重叠，不应该插入，返回false\r\n                    return false;\r\n                }\r\n            }\r\n            if (leftTag) {//根据tag确定是父亲的左子还是右子\r\n                pre.left = new Node(start, end);\r\n            } else {\r\n                pre.right = new Node(start, end);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n*/\r\n\r\n/**\r\n * Your MyCalendar object will be instantiated and called as such:\r\n * MyCalendar obj = new MyCalendar();\r\n * boolean param_1 = obj.book(start,end);\r\n */\r\n"}