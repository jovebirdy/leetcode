{
  "java": "/*\n * [729] My Calendar I\n *\n * https://leetcode.com/problems/my-calendar-i/description/\n *\n * algorithms\n * Medium (42.15%)\n * Total Accepted:    10K\n * Total Submissions: 23.6K\n * Testcase Example:  '[\"MyCalendar\",\"book\",\"book\",\"book\"]\\n[[],[10,20],[15,25],[20,30]]'\n *\n *\n * Implement a MyCalendar class to store your events. A new event can be added\n * if adding the event will not cause a double booking.\n *\n * Your class will have the method, book(int start, int end).  Formally, this\n * represents a booking on the half open interval [start, end), the range of\n * real numbers x such that start .\n *\n * A double booking happens when two events have some non-empty intersection\n * (ie., there is some time that is common to both events.)\n *\n * For each call to the method MyCalendar.book, return true if the event can be\n * added to the calendar successfully without causing a double booking.\n * Otherwise, return false and do not add the event to the calendar.\n *\n *\n * Your class will be called like this:\n * MyCalendar cal = new MyCalendar();\n * MyCalendar.book(start, end)\n *\n * Example 1:\n *\n * MyCalendar();\n * MyCalendar.book(10, 20); // returns true\n * MyCalendar.book(15, 25); // returns false\n * MyCalendar.book(20, 30); // returns true\n * Explanation:\n * The first event can be booked.  The second can't because time 15 is already\n * booked by another event.\n * The third event can be booked, as the first event takes every time less than\n * 20, but not including 20.\n *\n *\n *\n * Note:\n * The number of calls to MyCalendar.book per test case will be at most 1000.\n * In calls to MyCalendar.book(start, end), start and end are integers in the\n * range [0, 10^9].\n *\n */\nclass MyCalendar {\n\n    class Node {//\u8282\u70b9\u6709\u8d77\u59cb\u7ed3\u675f\u65f6\u95f4\u548c\u5de6\u53f3\u5b50\u8282\u70b9\n        public Node(int start, int end) {\n            l = start;\n            r = end;\n        }\n\n        int l, r;\n        Node left, right;\n    }\n\n    Node root = null;\n\n    public boolean book(int start, int end) {\n        if (root == null) {\n            root = new Node(start, end);\n        } else {\n            Node cur = root;\n            Node pre = null;//\u7236\u8282\u70b9\n            boolean leftTag = false;//\u8bb0\u5f55\u8be5\u63d2\u5165\u7684\u8282\u70b9\u662f\u5de6\u5b50\u8fd8\u662f\u53f3\u5b50\n            while (cur != null) {\n                pre = cur;\n                if (end <= cur.l) {//\u5e94\u8be5\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u4fa7\uff0c\u5f80\u5de6\u5b50\u9012\u5f52\n                    leftTag = true;\n                    cur = cur.left;\n                } else if (start >= cur.r) {//\u5e94\u8be5\u5728\u5f53\u524d\u8282\u70b9\u7684\u53f3\u4fa7\uff0c\u5f80\u53f3\u5b50\u9012\u5f52\n                    leftTag = false;\n                    cur = cur.right;\n                } else {// \u6709\u91cd\u53e0\uff0c\u4e0d\u5e94\u8be5\u63d2\u5165\uff0c\u8fd4\u56defalse\n                    return false;\n                }\n            }\n            if (leftTag) {//\u6839\u636etag\u786e\u5b9a\u662f\u7236\u4eb2\u7684\u5de6\u5b50\u8fd8\u662f\u53f3\u5b50\n                pre.left = new Node(start, end);\n            } else {\n                pre.right = new Node(start, end);\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * Your MyCalendar object will be instantiated and called as such:\n * MyCalendar obj = new MyCalendar();\n * boolean param_1 = obj.book(start,end);\n */\n"
}