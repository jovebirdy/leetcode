## 第一题

作为leetcode的第一题，回想起第一次刷这道题的时候还是挺有感触的哈。

一开始决定用JS刷题，但是后来刷得过程中才深深的觉察到JS还是太过于不严谨，比如一个{}花括号就可以实现Map了，但是具体他的底层实现你并不知道，也很难分析性能。再比如你用数组就可以实现队列、堆栈，Array实例都带了`shift()`,`unshift()`,`push()`,`pop()`等方法，甚至提供了`slice()`,`splice()`等方法对数组进行切割、插入、删除元素等操作，但是这些API的提供带来的问题是你无法真正的衡量一个算法的效率，或者换句话说，你本应该自己在算法层面实现的一些操作在JS里却可以作弊一样使用API来完成，`slice()`,`splice()`等的具体实现细节你都并不真正的明白，比如你有一个操作需要将数组的某个位置以后的所有元素后移从而腾出一个位置供你插入元素，在java、c、c++里你只能循环的去做，那这个操作应该是O（n）的，但是你用`splice()`的话，会给你一种O(1)的错觉。因此我用JS刷了2、3道之后就放弃了用JS，从头学JAVA并用JAVA刷题。

### 回到题目上来
2-sum其实属于n-sum系列当中的一个，我当时在写的时候，因为在JS里实现一个map真的的太太太方便了，就直接用了一个对象作为HashMap，然后遍历数组，看当前元素是否在HashMap里，不在的话，就把target减去当前元素作为`key`、把下标作为`value`放进Map里，表示以后遇到一个元素值为这个`key`的话，它就能和`value`下标的元素加起来成为target。

上面这种方法，我一开始写的时候觉得很好，但是那其实是我作为一个JS程序员的直觉，因为我会觉得只用了一个对象`{}`，性能也是O(n)，但是其实`{}`应该在底层使用HashMap实现的，空间开销并不小。

另外一种方法就是two-pointers，先对数组排序，排序之后一前一后俩指针，先计算俩指针指的元素的加和`sum`，如果`sum`比target大，那说明后面的那个指针指向的值太大了，让他往前移动，反之则前面的指针往后移动，这样遍历的去寻找结果。
