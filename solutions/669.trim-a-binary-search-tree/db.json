{
  "java": "/*\n * [669] Trim a Binary Search Tree\n *\n * https://leetcode.com/problems/trim-a-binary-search-tree/description/\n *\n * algorithms\n * Easy (58.17%)\n * Total Accepted:    27.5K\n * Total Submissions: 47.3K\n * Testcase Example:  '[1,0,2]\\n1\\n2'\n *\n * \n * Given a binary search tree and the lowest and highest boundaries as L and R,\n * trim the tree so that all its elements lies in [L, R] (R >= L). You might\n * need to change the root of the tree, so the result should return the new\n * root of the trimmed binary search tree.\n * \n * \n * Example 1:\n * \n * Input: \n * \u2060   1\n * \u2060  / \\\n * \u2060 0   2\n * \n * \u2060 L = 1\n * \u2060 R = 2\n * \n * Output: \n * \u2060   1\n * \u2060     \\\n * \u2060      2\n * \n * \n * \n * Example 2:\n * \n * Input: \n * \u2060   3\n * \u2060  / \\\n * \u2060 0   4\n * \u2060  \\\n * \u2060   2\n * \u2060  /\n * \u2060 1\n * \n * \u2060 L = 1\n * \u2060 R = 3\n * \n * Output: \n * \u2060     3\n * \u2060    / \n * \u2060  2   \n * \u2060 /\n * \u20601\n * \n * \n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int L, int R) {\n        if (root == null) return root;\n        if (root.val > R) return trimBST(root.left, L, R);\n        if (root.val < L) return trimBST(root.right, L, R);\n\n        root.left = trimBST(root.left, L, R);\n        root.right = trimBST(root.right, L, R);\n        return root;\n    }\n}\n"
}