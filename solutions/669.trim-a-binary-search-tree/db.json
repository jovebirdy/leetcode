{"java":"/*\r\n * [669] Trim a Binary Search Tree\r\n *\r\n * https://leetcode.com/problems/trim-a-binary-search-tree/description/\r\n *\r\n * algorithms\r\n * Easy (58.17%)\r\n * Total Accepted:    27.5K\r\n * Total Submissions: 47.3K\r\n * Testcase Example:  '[1,0,2]\\n1\\n2'\r\n *\r\n * \r\n * Given a binary search tree and the lowest and highest boundaries as L and R,\r\n * trim the tree so that all its elements lies in [L, R] (R >= L). You might\r\n * need to change the root of the tree, so the result should return the new\r\n * root of the trimmed binary search tree.\r\n * \r\n * \r\n * Example 1:\r\n * \r\n * Input: \r\n * ⁠   1\r\n * ⁠  / \\\r\n * ⁠ 0   2\r\n * \r\n * ⁠ L = 1\r\n * ⁠ R = 2\r\n * \r\n * Output: \r\n * ⁠   1\r\n * ⁠     \\\r\n * ⁠      2\r\n * \r\n * \r\n * \r\n * Example 2:\r\n * \r\n * Input: \r\n * ⁠   3\r\n * ⁠  / \\\r\n * ⁠ 0   4\r\n * ⁠  \\\r\n * ⁠   2\r\n * ⁠  /\r\n * ⁠ 1\r\n * \r\n * ⁠ L = 1\r\n * ⁠ R = 3\r\n * \r\n * Output: \r\n * ⁠     3\r\n * ⁠    / \r\n * ⁠  2   \r\n * ⁠ /\r\n * ⁠1\r\n * \r\n * \r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode trimBST(TreeNode root, int L, int R) {\r\n        if (root == null) return root;\r\n        if (root.val > R) return trimBST(root.left, L, R);\r\n        if (root.val < L) return trimBST(root.right, L, R);\r\n\r\n        root.left = trimBST(root.left, L, R);\r\n        root.right = trimBST(root.right, L, R);\r\n        return root;\r\n    }\r\n}\r\n"}