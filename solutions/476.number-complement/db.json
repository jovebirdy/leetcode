{
  "java": "/*\n * [476] Number Complement\n *\n * https://leetcode.com/problems/number-complement/description/\n *\n * algorithms\n * Easy (61.04%)\n * Total Accepted:    73.9K\n * Total Submissions: 121.1K\n * Testcase Example:  '5'\n *\n * Given a positive integer, output its complement number. The complement\n * strategy is to flip the bits of its binary representation.\n * \n * Note:\n * \n * The given integer is guaranteed to fit within the range of a 32-bit signed\n * integer.\n * You could assume no leading zero bit in the integer\u2019s binary\n * representation.\n * \n * \n * \n * Example 1:\n * \n * Input: 5\n * Output: 2\n * Explanation: The binary representation of 5 is 101 (no leading zero bits),\n * and its complement is 010. So you need to output 2.\n * \n * \n * \n * Example 2:\n * \n * Input: 1\n * Output: 0\n * Explanation: The binary representation of 1 is 1 (no leading zero bits), and\n * its complement is 0. So you need to output 0.\n * \n * \n */\nclass Solution {\n    public int findComplement(int num) {\n        String a = Integer.toBinaryString(num);\n\t\tStringBuffer b = new StringBuffer(a);\n\t\tfor (int i = 0; i < b.length(); i++) {\n\t\t\tif(b.charAt(i) == '0') \n\t\t\t\tb.setCharAt(i, '1');\n\t\t\telse\n\t\t\t\tb.setCharAt(i, '0');;\n\t\t}\n\t\ta = new String(b);\n\t\tint c = Integer.parseInt(a, 2);\n\t\treturn c;\n    }\n}\n"
}