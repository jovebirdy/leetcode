{"java":"/*\r\n * [476] Number Complement\r\n *\r\n * https://leetcode.com/problems/number-complement/description/\r\n *\r\n * algorithms\r\n * Easy (61.04%)\r\n * Total Accepted:    73.9K\r\n * Total Submissions: 121.1K\r\n * Testcase Example:  '5'\r\n *\r\n * Given a positive integer, output its complement number. The complement\r\n * strategy is to flip the bits of its binary representation.\r\n * \r\n * Note:\r\n * \r\n * The given integer is guaranteed to fit within the range of a 32-bit signed\r\n * integer.\r\n * You could assume no leading zero bit in the integerâ€™s binary\r\n * representation.\r\n * \r\n * \r\n * \r\n * Example 1:\r\n * \r\n * Input: 5\r\n * Output: 2\r\n * Explanation: The binary representation of 5 is 101 (no leading zero bits),\r\n * and its complement is 010. So you need to output 2.\r\n * \r\n * \r\n * \r\n * Example 2:\r\n * \r\n * Input: 1\r\n * Output: 0\r\n * Explanation: The binary representation of 1 is 1 (no leading zero bits), and\r\n * its complement is 0. So you need to output 0.\r\n * \r\n * \r\n */\r\nclass Solution {\r\n    public int findComplement(int num) {\r\n        String a = Integer.toBinaryString(num);\r\n\t\tStringBuffer b = new StringBuffer(a);\r\n\t\tfor (int i = 0; i < b.length(); i++) {\r\n\t\t\tif(b.charAt(i) == '0') \r\n\t\t\t\tb.setCharAt(i, '1');\r\n\t\t\telse\r\n\t\t\t\tb.setCharAt(i, '0');;\r\n\t\t}\r\n\t\ta = new String(b);\r\n\t\tint c = Integer.parseInt(a, 2);\r\n\t\treturn c;\r\n    }\r\n}\r\n"}