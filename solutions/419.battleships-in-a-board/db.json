{
  "java": "/*\n * [419] Battleships in a Board\n *\n * https://leetcode.com/problems/battleships-in-a-board/description/\n *\n * algorithms\n * Medium (62.97%)\n * Total Accepted:    41K\n * Total Submissions: 65.2K\n * Testcase Example:  '[[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]'\n *\n * Given an 2D board, count how many battleships are in it. The battleships are\n * represented with 'X's, empty slots are represented with '.'s. You may assume\n * the following rules:\n * \n * \n * You receive a valid board, made of only battleships or empty slots.\n * Battleships can only be placed horizontally or vertically. In other words,\n * they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1\n * column), where N can be of any size.\n * At least one horizontal or vertical cell separates between two battleships -\n * there are no adjacent battleships.\n * \n * \n * Example:\n * X..X\n * ...X\n * ...X\n * \n * In the above board there are 2 battleships.\n * \n * Invalid Example:\n * ...X\n * XXXX\n * ...X\n * \n * This is an invalid board that you will not receive - as battleships will\n * always have a cell separating between them.\n * \n * Follow up:Could you do it in one-pass, using only O(1) extra memory and\n * without modifying the value of the board?\n */\nclass Solution {\n    public int countBattleships(char[][] board) {\n        if (board == null || board.length == 0 || board[0].length == 0) return 0;\n\tint R = board.length, C = board[0].length, cnt = 0;\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tif (board[i][j] == 'X' && (i == 0 || board[i - 1][j] == '.') && (j == 0 || board[i][j - 1] == '.'))\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\treturn cnt;\n    }\n}\n"
}