{"java":"/*\r\n * [747] Min Cost Climbing Stairs\r\n *\r\n * https://leetcode.com/problems/min-cost-climbing-stairs/description/\r\n *\r\n * algorithms\r\n * Easy (43.36%)\r\n * Total Accepted:    20.1K\r\n * Total Submissions: 46.3K\r\n * Testcase Example:  '[0,0,0,0]'\r\n *\r\n *\r\n * On a staircase, the i-th step has some non-negative cost cost[i] assigned (0\r\n * indexed).\r\n *\r\n * Once you pay the cost, you can either climb one or two steps. You need to\r\n * find minimum cost to reach the top of the floor, and you can either start\r\n * from the step with index 0, or the step with index 1.\r\n *\r\n *\r\n * Example 1:\r\n *\r\n * Input: cost = [10, 15, 20]\r\n * Output: 15\r\n * Explanation: Cheapest is start on cost[1], pay that cost and go to the\r\n * top.\r\n *\r\n *\r\n *\r\n * Example 2:\r\n *\r\n * Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\r\n * Output: 6\r\n * Explanation: Cheapest is start on cost[0], and only step on 1s, skipping\r\n * cost[3].\r\n *\r\n *\r\n *\r\n * Note:\r\n *\r\n * cost will have a length in the range [2, 1000].\r\n * Every cost[i] will be an integer in the range [0, 999].\r\n *\r\n *\r\n */\r\n\r\nclass Solution {\r\n    //状态转移方程 f(n) = min{[f(n-1)+cost(n)], [f(n-2)+cost(n)]\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int[] mc = new int[cost.length + 1];\r\n        mc[0] = cost[0];\r\n        mc[1] = cost[1];\r\n\r\n        for (int i = 2; i <= cost.length; i++) {\r\n            int costV = (i == cost.length) ? 0 : cost[i];\r\n            mc[i] = Math.min(mc[i - 1] + costV, mc[i - 2] + costV);\r\n        }\r\n        return mc[cost.length];\r\n    }\r\n}\r\n"}