{
  "java": "/*\n * [338] Counting Bits\n *\n * https://leetcode.com/problems/counting-bits/description/\n *\n * algorithms\n * Medium (62.17%)\n * Total Accepted:    107.1K\n * Total Submissions: 172.2K\n * Testcase Example:  '2'\n *\n * Given a non negative integer number num. For every numbers i in the range 0\n * \u2264 i \u2264 num calculate the number of 1's in their binary representation and\n * return them as an array.\n * \n * \n * Example:\n * For num = 5 you should return [0,1,1,2,1,2].\n * \n * \n * Follow up:\n * \n * It is very easy to come up with a solution with run time\n * O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a\n * single pass?\n * Space complexity should be O(n).\n * Can you do it like a boss? Do it without using any builtin function like\n * __builtin_popcount  in c++ or in any other language.\n * \n * \n * \n * Credits:Special thanks to @ syedee  for adding this problem and creating all\n * test cases.\n */\nclass Solution {\n    public int[] countBits(int num) {\n        int[] f = new int[num+1];\n        for(int i = 1; i <= num; i++){\n            f[i] = f[i / 2] + i % 2;\n        }\n        return f;\n    }\n}\n"
}