{"java":"/*\r\n * [338] Counting Bits\r\n *\r\n * https://leetcode.com/problems/counting-bits/description/\r\n *\r\n * algorithms\r\n * Medium (62.17%)\r\n * Total Accepted:    107.1K\r\n * Total Submissions: 172.2K\r\n * Testcase Example:  '2'\r\n *\r\n * Given a non negative integer number num. For every numbers i in the range 0\r\n * ≤ i ≤ num calculate the number of 1's in their binary representation and\r\n * return them as an array.\r\n * \r\n * \r\n * Example:\r\n * For num = 5 you should return [0,1,1,2,1,2].\r\n * \r\n * \r\n * Follow up:\r\n * \r\n * It is very easy to come up with a solution with run time\r\n * O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a\r\n * single pass?\r\n * Space complexity should be O(n).\r\n * Can you do it like a boss? Do it without using any builtin function like\r\n * __builtin_popcount  in c++ or in any other language.\r\n * \r\n * \r\n * \r\n * Credits:Special thanks to @ syedee  for adding this problem and creating all\r\n * test cases.\r\n */\r\nclass Solution {\r\n    public int[] countBits(int num) {\r\n        int[] f = new int[num+1];\r\n        for(int i = 1; i <= num; i++){\r\n            f[i] = f[i / 2] + i % 2;\r\n        }\r\n        return f;\r\n    }\r\n}\r\n"}